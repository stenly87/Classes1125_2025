using TestNamespace;
using static System.Net.Mime.MediaTypeNames;
internal class Program
{
    delegate void TestDelegate();

    static Table test;
    private static void Main(string[] args)
    {
        TestMethod();
        // зовем GC собрать мусор
        GC.Collect();
        // Классы в c#
        // (┬┬﹏┬┬)

        // класс - это ссылочный тип данных
        // составной тип данных (как и структура (struct) и запись (record)
        // структуры и записи в основном идеоматично связаны
        // с неизменяемыми данными (в основном значимыми типами)
        // для создания класса нам нужно:
        // модификатор доступа (статичный или нет) class ИмяКласса
        // { тело класса }
        // Мы можем создавать экземпляры класса
        // экземпляр можно использовать только после 
        // инициализации "= new Тип(аргументы);"
        // инициализация выполняет один из конструкторов класса
        // инициализация приводит к созданию начальных данных 
        // внутри экземпляра (объекта) класса
        // полное название класса включает в себя все пространства
        // имен, внутри которых расположен класс
        Human human1 = new Human(); // <-- конструктор без аргументов или по умолчанию
        Console.WriteLine(human1);
        Human human2 = new Human("Виктор"); // <-- срабатывает другой конструтор
        Console.WriteLine(human2);
        // в классе можно объявить поле
        // поле - это просто переменная, имя с маленькой буковки
        // доступ к полю обычно private или protected
        // при создании экземпляра выполняется конструктор
        // если мы его не создавали, выполняется конструктор по умолчанию
        // конструктор по умолчанию в принципе ничего не делает,
        // разве что поля со значимым типом получат значение по умолчанию
        // конструтор объявляется как метод, отличие в том, 
        // что у конструктора нет возращаемого типа и название
        // всегда совпадает с именем класса
        // в одном классе может быть несколько конструкторов
        // они должны различаться набором аргументов
        // ключевое слово this - помогает обращаться к элементам,
        // объявленным в классе (при наследовании конструктора тоже)
        Human human3 = new Human("Павел", 18);
        human3.Print();
        human3.Name = "Марьяна";
        human3.Print();
        Console.WriteLine(human3.Name);
        try
        { // выполнение потенциально опасного кода
            // должно быть внутри блока try catch
            human3.Age = 17;
        } // при ошибке мы можем получить объект ошибки
        catch (Exception ex)
        { // и вывести информацию или как-нибудь обработать ошибку
            Console.WriteLine(ex.Message);
        }
        // блок finally в конструкции try catch необязательный,
        // включает в себя код, который обязательно выполнится
        // неважно будет ошибка или нет
        finally
        {
            human3.Print();
        }
        // есть также статичный конструктор, он может быть только один
        // статичный конструктор объявляется как static ИмяКласса()
        // модификаторы доступа у конструкторов могут быть разными
        // кроме статичного конструктора, там модификатора нет
        // если констукторов нет или есть конструктор без аргументов
        // то можно инициализировать свойства класса примерно так:
        Human human4 = new Human { Name = "Василий", Age = 20 };
        human4.Print();

        // в классе можно также объявлять свойства
        // свойство это оболочка, которая управляет полем
        // свойство при компиляции преобразовывается в 2 метода
        // один метод возращает значение, второй - назначает значение в поле
        // свойство включает в себя блоки get и set (или один из них). 
        // get должен возращать через return значение по типу соответствующее типу свойства
        // set может обратиться к value, чтобы узнать, что пытаются записать в свойство
        // Есть короткая запись свойства, когда мы не указываем поле (оно создается автоматически)
        // модификаторы тип Имя {get;set;}
        // свойства обычно имеют модификатор доступа public
        // static свойства обычно бывают только в static классах
        // свойства (а точнее поля) задают состояние объекта

        // деструктор
        // деструктор в классе может быть только один, часто его нет
        // объявляется как ~ИмяКласса()
        // Деструктор выполняется, когда системный сборщик мусора
        // (Garbage Collector, GC) удаляет объект из памяти
        // удаление объектов происходит, когда на них нет ссылок из других объектов
        // удаление происходит не сразу, а когда GC доберется до объекта-сироты
        // деструкторы нужны в тех случаях, когда объект
        // работает с некоторыми ресурсами, которые нужно
        // закрывать, очищать и тп (например файлы, стримы в другие приложения и тп)
        // чувствительный код в деструкторе располагать нельзя
        // поскольку он может не выполниться ни разу

        // индексатор
        // индексатор позволяет обращаться к объекту по индексу
        // получать и задавать туда данные
        // пример 
        Group group = new Group();
        group[1] = "Петров"; // задаем значение через индексатор
        Console.WriteLine(group[1]); // получаем значение через индексатор

        //такой цикл не будет работать
        //пока класс Group не реализует интерфейс IEnumerable
        //foreach (var item in group)
        //{
        //}

        // события
        // объявляются через event
        // событие требует делегат
        // делегат это ссылка на метод

        // при объявлении делегат (delegate) указывает тип возращаемого значения
        // и набор аргументов, например:
        // delegate void TestDelegate();
        // delegate int TestDelegateSum(int x, int y);
        // делегаты объявляются в пространстве имен и внутри классов
        // тип делегата и его аргументы задают условие
        // для того, на какие методы может ссылаться делегат
        // метод должен совпадать с делегатом по типу и аргументам
        // варианты использования:
        // создаем делегат и нацеливаем его на метод Sum
        TestDelegateSum testDelegateSum = new TestDelegateSum(Sum);
        // тоже самое, но без new
        testDelegateSum = Sum;
        // делегат может ссылаться на насколько методов
        // каждый новый метод добавляется через +=
        testDelegateSum += Mult; // подписка
        testDelegateSum += Mult; // двойная! подписка
        // если нужно, метод из делегата можно убрать
        //testDelegateSum -= Mult; // отписка

        // выполнение делегата
        // если делегат возвращает значение и ссылается на 
        // несколько методов, мы получим результат из последнего
        // метода в списке (выполнятся все)
        int result = testDelegateSum(10, 10);
        Console.WriteLine(result);
        // в фреймворке есть заранее определенные типы
        // Action и Func с помощью которых можно легко
        // создать делегат с нужным набором аргументов
        // Action - void
        // Func - имеет тип возращаемого значения
        // аналог TestDelegateSum:
        // последний int это тип возращаемого значения
        Func<int, int, int> func = Sum;
        Console.WriteLine(func(5, 5));
        // вызов делегата, который ни на что не указывает
        // приведет к исключению

        // событие объявляется с помощью делегата EventHandler
        Table table = new Table();
        table.TitleChanged += Table_TitleChanged; // подписка на событие
        table.Title = "Вызовем событие, изменив Title";
        Console.ReadLine();
    }

    private static void Table_TitleChanged(object? sender, string newTitle)
    {
        Console.WriteLine("Кто-то переименовал стол!");
        Console.WriteLine("Новое имя стола: " + newTitle);
    }

    delegate int TestDelegateSum(int x, int y);

    public static int Sum(int x1, int y1)
    {
        Console.WriteLine($"{x1} + {y1} = {x1+y1}");
        return x1 + y1;
    }
    public static int Mult(int x1, int y1)
    {
        Console.WriteLine($"{x1} * {y1} = {x1 * y1}");
        return x1 * y1;
    }
    public static void TestMethod()
    {
        // ссылка test будет содержать ссылку на объект
        // после завершения метода
        // объект по ссылке test не будет уничтожен
        test = new Table { Title = "Я буду жить" };
        
        // ссылка h1 по окончанию метода уничтожится
        // объект, на который она ведет, будет висеть в памяти
        // он станет сиротой
        // его прикончит GC через некоторое время
        // мы не можем сказать когда это произойдет
        // но мы можем позвать GC принудительно
        var h1 = new Table { Title = "Зима близко" };

        //List<Table> list = new List<Table>();
        //for (int i = 0; i < 1000000; i++)
        //    list.Add(new Table { Title = "Зима близко " + i });

        // создание множества объектов без ссылок может спровоцировать 
        // GC начать работать сразу
        //for (int i = 0; i < 1000000; i++)
        //    new Table { Title = "Зима близко " + i };

    }
}
